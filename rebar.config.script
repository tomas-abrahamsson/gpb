%% -*- erlang -*-

NoHaveMapsOpts = try maps:size(maps:new()) of
                     0 -> []
                 catch error:undef -> [{d,'NO_HAVE_MAPS',true}]
                 end.

%% In Erlang 19, the random module is deprecated
NoHaveRandOpts = try rand:uniform() of
                     F when is_float(F) -> []
                 catch error:undef -> [{d,'NO_HAVE_RAND',true}]
                 end.

%% In Erlang 21, a number of string module functions are deprecated:
%%   string:join/2 -> lists:join/2       (appeared in Erlang 19)
%%   string:str/2  -> string:find/2      (appeared in Erlang 20)
%%   string:substr/2 -> string:slice/2   (appeared in Erlang 20)
%%   string:tokens/2 -> string:lexemes/2 (appeared in Erlang 20)
%%   string:{to_lower,to_upper}/1 ->  and string:{lowercase,uppercase}/1
NoHaveErl20StrFunctions =
                 try string:find("abc", "b") of
                     "bc" -> []
                 catch error:undef -> [{d,'NO_HAVE_ERL20_STR_FUNCTIONS'}]
                 end.

%% In Erlang 21, the function erlang:get_stacktrace() is deprecated,
%% and there is new syntax for retrieving the stacktrace:
%%   try ...
%%   catch Class:Reason:Stacktrace -> ...
%%   end
NoHaveStacktraceSyntax =
                 case erlang:system_info(otp_release) of
                     "R"++_  -> [{d,'NO_HAVE_STACKTRACE_SYNTAX'}];
                     "17"++_ -> [{d,'NO_HAVE_STACKTRACE_SYNTAX'}];
                     "18"++_ -> [{d,'NO_HAVE_STACKTRACE_SYNTAX'}];
                     "19"++_ -> [{d,'NO_HAVE_STACKTRACE_SYNTAX'}];
                     "20"++_ -> [{d,'NO_HAVE_STACKTRACE_SYNTAX'}];
                     _       -> []
                 end.

HaveRebar3 = erlang:function_exported(rebar3, main, 1).

NoHaveProper = case HaveRebar3 of
                   true ->
                       %% We have proper via the "as test" dependency
                       [];
                   false ->
                       %% Rebar 2.x.  Use rebar3 to test the properties.
                       %% (There is theoretically still the possibility that
                       %% proper is available, eg via $ERL_LIBS or similar,
                       %% but prop_gpb still needs rebar3_proper to run.)
                       [{d,'NO_HAVE_PROPER'}]
               end.

ConfigOpts = NoHaveMapsOpts ++ NoHaveRandOpts ++ NoHaveErl20StrFunctions ++
                 NoHaveStacktraceSyntax ++ NoHaveProper.

[{require_otp_vsn, ".*"},

 {pre_hooks,
  [{compile,
    %% invoking shell script as an argument to sh appears to  be
    %% needed with rebar for windows/cygwin
    "bash build/mk_version_hrl"
    "    < include/gpb_version.hrl.in"
    "    > include/gpb_version.hrl "}
  ]},

 %% Erlang compiler options
 {erl_opts, [debug_info] ++ ConfigOpts},

 {erl_first_files, ["src/gpb_codegen.erl"]},

 %% This line is useful if you have gpb_eqc.erl symlinked to
 %% the symlink in the test/ directory.
 {eunit_compile_opts, [{i,"../include"}]},
 {profiles,
  [{test, [{deps, [proper]}
          ,{plugins, [rebar3_proper]}
          ]}
  ]},

 {edoc_opts, [{preprocess,true}, {pretty_printer,erl_pp}]},

 {post_hooks,
  [{compile,
    %% way of invoking shell script: see above
    "sh -c \""
    "  sh build/prepend_edoc_autogenerated src/gpb_scan.erl src/gpb_scan.xrl"
    "  &&"
    "  sh build/compile_descriptor"
    "\""}]},

 %% XRef checks to perform
 {xref_checks, [undefined_function_calls]},

 %% Clean files
 {clean_files, [".eunit", "ebin/*.beam", "include/gpb_version.hrl",
                "descr_src/gpb_descriptor.erl", "descr_src/gpb_descriptor.hrl"]}
].
